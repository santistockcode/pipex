### 📋 Pipex Task-Break-Down (aligns with v3.2 subject)

Below is a lean, sprint-style backlog that satisfies **every MUST** in the mandatory part, positions you for **perfect bonus**, and already plants seeds you’ll reuse in Minishell.  Keep it in a kanban/issue board and tick ✓ when done.

| Phase | Task (granular) | “Definition of Done” / Hints |
|-------|-----------------|------------------------------|
| **0 Scaffold & Tooling** | • Create repo tree `src/ include/ libft/ tests/ docs/` <br>• Copy/libft + Makefile with rules `$(NAME) all clean fclean re bonus` <br>• Add `-Wall -Wextra -Werror` + Norminette target <br>• Pre-hook: `clang-format` or `norminette` | `make` builds without relink & no Norminette errors.<br>CI 🅴: GH Actions `make && valgrind --leak-check=full` passes. |
| **1 Argument & PATH parsing** | 1. Validate count & syntax: `infile cmd1 cmd2 outfile` vs `here_doc LIMITER …` <br>2. Split `$PATH`, cache dirs, `find_cmd()` returns absolute path or `NULL` <br>3. Escape/quote handling 🅴 (only basics needed for 42) | Unit test: print parsed plan; wrong args → same error msgs/exit codes as bash pipeline. |
| **2 Single Pipe Pipeline** (mandatory core) | • Build `pipe()`, `fork()` once <br>• In child 1: `dup2(in_fd, STDIN)` → exec cmd1 <br>• In child 2: `dup2(out_fd, STDOUT)` → exec cmd2 <br>• Parent closes unused FDs, waits & propagates last child status | `./pipex infile "cat" "wc -l" outfile` identical to `< infile cat | wc -l > outfile`. Checked with `diff`. |
| **3 Error-path Hardening** | • Wrapper `xmalloc()`, `xdup2()`, etc. on syscall fail → free+close, `perror()` then `exit(1)` <br>• Cover: invalid file, permission denied, cmd not found, wrong PATH, pipe/create errors | Run 42 testers & your own: no leaks (`valgrind`), no unexpected signals. |
| **4 Leak & Resource Audit** | • `valgrind` scripted run for success & all simulated failures <br>• `lsof -p` (🅴) to double-check closed FDs | Zero “definitely lost” bytes, only 3 standard FDs left open in parent. |
| **5 Bonus A – Multiple pipes** | • Build vector `{n-1} pipes`, loop forks, plug in/out, close aggressively <br>• Wait for all, return last cmd status | `./pipex infile cmd1 cmd2 cmd3 cmd4 outfile` == shell pipeline result. Stress test with 100 cmds generated by Python. |
| **6 Bonus B – here_doc & redirect >>** | • Detect `here_doc LIMITER … outfile` <br>• Read stdin until LIMITER into tmp pipe <br>• Open outfile with `O_APPEND` for `>>` | Matches `cmd << LIMITER | cmd1 >> outfile`. Also supports multiple cmds in between. |
| **7 Signals & Exit codes 🅴** | • Parent ignores SIGINT while children execute <br>• Return last child exit status (bash compatibility) | `echo $?` after running pipex under various failures equals bash pipeline’s result. |
| **8 Testing & Docs** | • Shell scripts comparing outputs vs real bash <br>• `README.md`: build, usage, limits, bonus <br>• Inline Doxygen for public helpers | README passes peer evaluation checklist; tests green on Linux VM & evaluator. |

#### Tips & Improvements

1. **Wrap all syscalls** (`xopen`, `xpipe`, `xfork`) so 90 % of error handling lives in one C file.  
2. **One global struct** (`t_px`) holding pipes array, pids, envp ⇒ simplifies cleanup.  
3. **Free list of strings** with one helper `ft_free_split(char **)` you’ll reuse in Minishell.  
4. **Keep libft unmodified**; add pipex-specific utilities separately to avoid Norminette surprises.  
5. **Git branches**: create one per phase; merge only when leak-free and Norm-clean.  
6. **Future-proof**: write `exec_cmd(char *cmd, char **envp)` now—later you’ll swap parsing to Minishell without touching exec logic.

🏁  Follow this board and you’ll meet every mandatory bullet, earn the bonus, and own reusable building blocks for your next shell project. ¡Buen código!


COSAS: focus a tope en la documentación y testing tooling, por ahí puedo tirar. 