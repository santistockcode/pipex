### ğŸ“‹ Pipex Task-Break-Down (aligns with v3.2 subject)

Below is a lean, sprint-style backlog that satisfies **every MUST** in the mandatory part, positions you for **perfect bonus**, and already plants seeds youâ€™ll reuse in Minishell.  Keep it in a kanban/issue board and tick âœ“ when done.

| Phase | Task (granular) | â€œDefinition of Doneâ€ / Hints |
|-------|-----------------|------------------------------|
| **0 Scaffold & Tooling** | â€¢ Create repo tree `src/ include/ libft/ tests/ docs/` <br>â€¢ Copy/libft + Makefile with rules `$(NAME) all clean fclean re bonus` <br>â€¢ Add `-Wall -Wextra -Werror` + Norminette target <br>â€¢ Pre-hook: `clang-format` or `norminette` | `make` builds without relink & no Norminette errors.<br>CI ğŸ…´: GH Actions `make && valgrind --leak-check=full` passes. |
| **1 Argument & PATH parsing** | 1. Validate count & syntax: `infile cmd1 cmd2 outfile` vs `here_doc LIMITER â€¦` <br>2. Split `$PATH`, cache dirs, `find_cmd()` returns absolute path or `NULL` <br>3. Escape/quote handling ğŸ…´ (only basics needed for 42) | Unit test: print parsed plan; wrong args â†’ same error msgs/exit codes as bash pipeline. |
| **2 Single Pipe Pipeline** (mandatory core) | â€¢ Build `pipe()`, `fork()` once <br>â€¢ In child 1: `dup2(in_fd, STDIN)` â†’ exec cmd1 <br>â€¢ In child 2: `dup2(out_fd, STDOUT)` â†’ exec cmd2 <br>â€¢ Parent closes unused FDs, waits & propagates last child status | `./pipex infile "cat" "wc -l" outfile` identical to `< infile cat | wc -l > outfile`. Checked with `diff`. |
| **3 Error-path Hardening** | â€¢ Wrapper `xmalloc()`, `xdup2()`, etc. on syscall fail â†’ free+close, `perror()` then `exit(1)` <br>â€¢ Cover: invalid file, permission denied, cmd not found, wrong PATH, pipe/create errors | Run 42 testers & your own: no leaks (`valgrind`), no unexpected signals. |
| **4 Leak & Resource Audit** | â€¢ `valgrind` scripted run for success & all simulated failures <br>â€¢ `lsof -p` (ğŸ…´) to double-check closed FDs | Zero â€œdefinitely lostâ€ bytes, only 3 standard FDs left open in parent. |
| **5 Bonus A â€“ Multiple pipes** | â€¢ Build vector `{n-1} pipes`, loop forks, plug in/out, close aggressively <br>â€¢ Wait for all, return last cmd status | `./pipex infile cmd1 cmd2 cmd3 cmd4 outfile` == shell pipeline result. Stress test with 100 cmds generated by Python. |
| **6 Bonus B â€“ here_doc & redirect >>** | â€¢ Detect `here_doc LIMITER â€¦ outfile` <br>â€¢ Read stdin until LIMITER into tmp pipe <br>â€¢ Open outfile with `O_APPEND` for `>>` | Matches `cmd << LIMITER | cmd1 >> outfile`. Also supports multiple cmds in between. |
| **7 Signals & Exit codes ğŸ…´** | â€¢ Parent ignores SIGINT while children execute <br>â€¢ Return last child exit status (bash compatibility) | `echo $?` after running pipex under various failures equals bash pipelineâ€™s result. |
| **8 Testing & Docs** | â€¢ Shell scripts comparing outputs vs real bash <br>â€¢ `README.md`: build, usage, limits, bonus <br>â€¢ Inline Doxygen for public helpers | README passes peer evaluation checklist; tests green on Linux VM & evaluator. |

#### Tips & Improvements

1. **Wrap all syscalls** (`xopen`, `xpipe`, `xfork`) so 90 % of error handling lives in one C file.  
2. **One global struct** (`t_px`) holding pipes array, pids, envp â‡’ simplifies cleanup.  
3. **Free list of strings** with one helper `ft_free_split(char **)` youâ€™ll reuse in Minishell.  
4. **Keep libft unmodified**; add pipex-specific utilities separately to avoid Norminette surprises.  
5. **Git branches**: create one per phase; merge only when leak-free and Norm-clean.  
6. **Future-proof**: write `exec_cmd(char *cmd, char **envp)` nowâ€”later youâ€™ll swap parsing to Minishell without touching exec logic.

ğŸ  Follow this board and youâ€™ll meet every mandatory bullet, earn the bonus, and own reusable building blocks for your next shell project. Â¡Buen cÃ³digo!


COSAS: focus a tope en la documentaciÃ³n y testing tooling, por ahÃ­ puedo tirar. 